[{"id":"4d0d662b78ac35b6510e9a9f36ef1ff9","title":"欢迎来到Tyy的个人博客！","content":"欢迎来到田远野的个人博客，我爱牛微微！\n","slug":"我爱牛微微","date":"2023-08-25T10:53:51.000Z","categories_index":"情感","tags_index":"情感","author_index":"假面骑士投"},{"id":"f70bf64eabbded8a2bd4b5fac72c7ba7","title":"从零开始搭建Hexo+Auroar个人博客！","content":"1.下载git和node搭建之前需要准备的软件：Git：官网下载：https://git-scm.com/Node.js 官网下载：http://nodejs.cn/\n以及:注册一个github账号\n2.安装Hexo在你喜欢的地方新建一个文件夹，在新建的文件夹路径上输入cmd，就会直接打开当前目录下的命令窗口\n\n执行npm i hexo，这里我使用的是cnpm，奈何没有wifi只能用热点npm下载总是报错，如果也遇到npm下载不下来可以配置一下淘宝镜像cnpm\n\n 下载好了之后就会生成几个文件，这样就是下载成功了！\n\n3.配置hexo环境变量第一次接触Hexo的朋友在执行hexo命令的时候会遇到命令不存在的问题，这个时候就需要去桌面右击我的电脑，点击属性就会出现以下弹窗，咱们点击高级系统设置，再点击环境变量\n\n\n接着找到系统变量，找到path这一行，咱们双击\n\n继续点击新建\n\n到一步了之后，咱们先去打开之前下载hexo的那个文件夹，里面不是生成了node_modules文件夹吗，点进去找到hexo文件夹，点进去，再点bin文件夹，然后复制整个路径下来\n\n\n复制下来的路径咱们直接放到刚才点击新建的那个地方\n\n注意：配置好了之后一定要点确定！ \n到现在咱们的环境变量就配置好了，可以继续搭建咱们的博客了，大家不要急躁，马上了\n4.完成本地搭建！回到咱们刚才下载hexo的文件夹下，咱们新建一个文件夹名字随便起，这个才是我们博客的文件夹，之前的文件夹只是为了给hexo配置环境变量！\n\n打开新建的文件夹，右键执行git bash ，执行命令 hexo init 咱们进行初始化\n注意：hexo init 只能在一个空的文件夹进行，否则会报错！\n\n这个时候基础项目就生成好了\n\n接着执行\ncnpm i ；（下载包）\n\nhexo g 或者 hexo generate（生成静态页面）\n\nhexo server (运行本地服务)\n\n 这个时候你如果环境变量配置都是安装我之前配置的，那么就没有任何问题\n\n 这时候访问localhost:4000就可以看到咱们的hexo页面啦！\n\n5.实现连接github仓库这一步是最关键的一步，可以让咱们的博客在远程服务器上部署！\n首先，需要有一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.io，举例如下：创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名.\n\n\n这一步完成了之后咱们就需要进行配置ssh公钥，这一步也很关键！\n打开C\\user\\你自己的电脑名\\文件下\n右键打开Git Bush 输入\nssh-keygen -t rsa -C 3314806775@qq.com\n\n\n改成你自己注册的github邮箱！！！\n接着你就会发现C\\user\\你自己的电脑名\\文件下多了一个.ssh文件夹，打开id_rsa.pub文件复制里面的内容，这就是咱们的公钥\n\n紧接着在github的设置里，咱们去配置这个公钥（不然就会一直报错，没有权限，当时折腾了我很久），点击New Shh Key，title随便起，key里把复制的内容粘贴过去，这样咱们的公钥就配置好啦！\n\n最后一步！！！\n打开咱们hexo项目文件夹，打开_config.yml文件，直接滑到最下面找到deploy更改配置,这一步就是为了把hexo和github连接起来\n\ndeploy:\n  type: git\n  repo: git@github.com:TyyGod&#x2F;TyyGod.github.io.git\n  branch: main\n\n\n完成这一步，保存，咱们接着在这个文件夹下右键打开GirBush，执行 npm install hexo-deployer-git –save  这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。\n\n最后依次执行以下命令：\n如果缩写没有命令直接执行全称就行\nhexo c     #清除缓存文件 db.json 和已生成的静态文件 public （hexoi clean）\nhexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)\nhexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)\n\n完成之后去github仓库中看一看\n\n这样就是成功了！！！\n 把前面的名字改成你自己的github名就好，后面.github.io不变即可\n\n可能你们看到的页面跟我不一样，这是因为我在hexo的基础上添加了Aurhora风格\n6.升级Hexo，变成Auroar Hexo！！！我只是为了项目样式更加好看，如果没有这方需求的朋友恭喜你们，你们已经完成搭建属于自己的博客了，至于想接着完善hexo的，那咱们继续，不过请放心，升级hexo相较于创建hexo非常简单\n步骤 1 - 安装主题包在控制台中，进入 Hexo 项目的根目录，然后运行以下命令安装主题\n注意\n对于版本 2.0+ 后，生成脚本全部移植到 hexo-plugin-aurora 包中。所以需要安装这个插件来使用这个主题!\nYARNNPMyarn add hexo-theme-aurora hexo-plugin-aurora\n步骤 2 - 生成主题配置因为主题是使用 NPM 或者 Yarn 安装的，而不是 clone 到 themes 文件夹的。所以我们需要自己创建一个配置文件。你只需要在 Hexo 博客的根目录下创建一个 _config.aurora.yml 配置文件来配置主题。\n要获取默认主题模板，对于 Linux 系统 (MacOS&#x2F;LinuxOS) 用户只需执行以下命令。\n对于 Windows 用户，您可以将下面的模板复制到 _config.aurora.yml 中。\nLinux 复制模版命令\ncp -rf .&#x2F;node_modules&#x2F;hexo-theme-aurora&#x2F;_config.yml .&#x2F;_config.aurora.yml也可以直接复制这个下面链接的模版到项目根目录的 _config.aurora.yml 中\nhttps://github.com/auroral-ui/hexo-theme-aurora/blob/main/_config.yml\n步骤 3 - Settingtheme因为要告诉 hexo 你要用的主题是 aurora 所以需要把 _config.yml 中的 theme 值改为 aurora\n打开在 Hexo 根目录下的 _config.yml修改把 theme 的值改为 aurora\n1. # Extensions\n2. ## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;\n3. ## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;\n4. theme: aurora\n\n\n\n步骤 4 - 设置permalink因为使用了 Vue-router，Hexo 默认生成的页面和文章的 permalink 与我们 Vue router 中的 path 是不相符的，那么就会出现无法访问的问题。所以我们需要修改 Hexo 默认配置文件里面的 permalink 参数。\n1.打开在 Hexo 根目录下的 _config.yml2.修改 permalink 参数为 &#x2F;post&#x2F;:title.html\n# URL\n\n## Set your site url here. For example, if you use GitHub Page, set url as &#39;https:&#x2F;&#x2F;username.github.io&#x2F;project&#39;\n\nurl: https:&#x2F;&#x2F;tridiamond.tech\npermalink: &#x2F;post&#x2F;:title.html\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks\n  trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks\n\n步骤 5 - 设置代码高亮最后主题是使用 Prismjs 来实现代码高亮显示，但 Hexo 默认是使用 highlightjs，因此你需要更改 Hexo 配置来使用 Prismjs:\n把 highlight 的启用改为false把 prismjs 的启用改为true把 prismjs 下的 preprocess 改为 false\nhighlight:\n  enable: false\n  line_number: true\n  auto_detect: false\n  tab_replace: &#39;&#39;\n  wrap: true\n  hljs: false\nprismjs:\n  enable: true\n  preprocess: false\n  line_number: true\n  tab_replace: &#39;&#39;\n\n步骤 6 - 创建 “关于 (about)” 页面主题默认开启了 about 页面，所以我们需要创建这个 about 页，要不主题就无法正常显示 about 页。\n#步骤 6 - 创建 “关于 (about)” 页面主题默认开启了 about 页面，所以我们需要创建这个 about 页，要不主题就无法正常显示 about 页。\n要创建这个默认的 about 页，只需要执行这个 Hexo 的命令：\nhexo new page about\n\n\n执行完毕后，你会发现在 source&#x2F; 文件中多处了一个新的文件夹：\n.\n└── source\n    └── about\n        └── index.md\n\n\n你可以随意修改这个 index.md markdown 文件中的内容，此文件的内容将会现在在我们的 about 页面中。\n步骤 7 - 重新生成与本地服务器使用以下命令来运行本地环境。\nhexo clean &amp; hexo g &amp; hexo server\n\n\n提示\n改变了任何配置都需要重新生成 Hexo 的静态文件！\n当文件都生成完毕之后，就可以通过 https://localhost:4000在新窗口打开 访问你的博客了。\n最后在在执行一下hexo deploy从新部署一下，就完成啦，升级hexo到服务端需要一点时间，如果发现页面没有变化的重启几次服务试一下\n最终的效果！\n\n最后感谢能看到这里的人，如果遇到了任何问题，可以直接评论我会第一时间回复的！\n","slug":"搭建hexo","date":"2022-11-25T10:53:51.000Z","categories_index":"技术","tags_index":"技术","author_index":"假面骑士投"},{"id":"4a088409b555ba0e65cf89101348b139","title":"减脂指南","content":"减脂科普\n1.在减脂人眼中食物的分类​\t\t\t在讲如何减脂之前，我们首先就需要了解各种食物的热量以及各种食物代表了什么。\n​\t\t\t我把食物分成了三大类  在我眼中食物只有三类 碳水食物 蛋白质食物 脂肪食物 。先记住这三大类，下面我讲讲这三大类都是什么东西。\n​\t\t\t首先，人体所需的三大基本营养素就是 碳水 蛋白质 脂肪，他们三兄弟支撑我们人正常的运作，这三者缺一不可。人吃的每一种食物不管是什么，都包含这三种营养素，只不过量不同。\n​\t\t\t\n2.长胖和变瘦的底层逻辑是什么？​\t\t\t人为什么会胖，又为什么会瘦？说白了，你摄入的热量（也就是吃的食物）大于你今天日常工作或者上学所消耗的热量，你就会长胖，什么意思呢？就是支撑你完成一天的工作或者任何事（生活一天）消耗的热量（人活着就得消耗热量，不然拿什么活着？）小于你今天吃的热量，多出来的热量，就是你长得肉。反之，你就会瘦。\n3.关于不健康的减肥​\t\t\t知道食物的分类和减脂的底层逻辑之后，就可以进行下一步，如何减脂。\n​\t\t\t看完上一个问题，咱们知道减肥就是只要我吃的热量小于我今天消耗的热量不就行了吗，有的人可能就会说，那我一天就吃一个苹果，今天我吃的热量绝对小于我消耗的热量了，我肯定会瘦！他大错特错！靠饿来减脂，根本不是一个长久之计，难道你能饿一辈子？刚开始你确实会瘦，等你瘦了七斤八斤之后，你又开始恢复之前的饮食了，大吃特吃。体重不过三天就会恢复，这就是所谓的”反弹”。并且单纯的靠饿去减肥，你刚开始确实会掉秤，过不了多久，你就会发现，体重不动了。这是为什么？\n3.1平台期​\t\t\t\t\t\t平台期，什么意思？当你一直吃的特别少，热量供不上的时候，你的身体就会强制开启保护措施，他就会觉得是不是闹饥荒了？天天不给我吃饭，这可不行，我得开始节约热量消耗了。这就是平台期，身体开始节约的消耗热量，导致你体重不变。\n3.2如何过渡平台期？​\t\t\t\t\t\t如果的真的进入到了平台期，或者体重一周以上没变动，这基本就是确定进入平台期了（你得确定你是在减肥，别天天吃老多，发现自己体重不动也以为自己进入了平台）\n两种解决办法：​\t\t\t\t\t\t1.不节食，自然就没有平台期\n​\t\t\t\t\t\t2.吃一顿放纵餐，告诉你的身体没有闹饥荒，不需要你来保护我，所谓欺骗身体就是这么来的。\n4.科学健康减脂（重点）​\t\t\t其实上面所有内容，都是为了健康科学减脂做铺垫，下面咱们进入正题：\n​\t\t\t\t\t既要摄入的热量少于消耗的热量，还要不反弹不掉头发，那咱们就来了解一种饮食法：\n低碳饮食法​\t\t\t\t\t\t那么低碳饮食法是什么咱们怎么吃，其实很简单，字面意思，少吃碳水，多吃肉。\n​\t\t\t\t\t\t这样的饮食好就好在，碳水吃的少，不会合成糖原，血糖不会升高，不容易发胖,还能大口吃肉。\n实施​\t\t\t\t\t\t少吃碳水食物，多吃蛋白和脂肪食物，碳水控制在100g左右即可\n5.我眼中的食物分类碳水类：​\t\t\t\t\t\t劣质碳水（加工之后的碳水，包含糖油混合物热量奇高）：\n​\t\t\t\t\t\t包子、油条、大饼、方便面、披萨、汉堡、元宵、煎饺、手抓饼、面条等等各种加工过的主食\n​\t\t\t\t\t\t优质碳水（升糖满，不如导致糖原溢出）：\n​\t\t\t\t\t\t土豆（不加工）、燕麦片、米饭、玉米（水煮）、火龙果、全麦面包、荞麦面\n蛋白质类：​\t\t\t\t\t\t优质蛋白：牛肉、鸡胸肉、鸡腿、鸡蛋白、蛋白粉、脱脂牛奶、去皮鸭肉\n​\t\t\t\t\t\t劣质蛋白（不仅仅包含蛋白质还携带了许多脂肪的肉类）：\n​\t\t\t\t\t\t汉堡、烤肉、炸鸡腿、炸串、\n脂肪类：​\t\t\t\t\t\t饱和脂肪（不容易被人体所代谢出去的脂肪也就是不好的脂肪）：各种动物的肉都包含饱和脂肪这\t\t\t\t\t\t\t\t是没办法的。\n​\t\t\t\t\t\t不饱和脂肪（利于人体代谢并且对人体有帮助的脂肪）：坚果、鱼油、牛油果、花生酱、芝麻酱、\t\t\t\t\t\t\t\t橄榄油、深海鱼。\n6.热量计算公式​\t\t\t\t\t男性的基础代谢率&#x3D;10×体重+6.25×身高-5×年龄+5 （一天的）\n​\t\t\t\t\t女性的基础代谢率&#x3D;10×体重+6.25×身高-5×年龄-161（一天的）\n​\t\t\t\t\t食物计算公式：1g碳水&#x3D;4大卡 1g蛋白质 &#x3D; 4大卡 1g脂肪 &#x3D; 8大卡\n","slug":"减脂科普","date":"2022-11-25T10:53:51.000Z","categories_index":"生活","tags_index":"","author_index":"假面骑士投"},{"id":"c083423f9c1faf2e9f82f25e0d9e1592","title":"js判断是否在可视范围","content":"js判断是否在可视范围完整代码\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n   &lt;div class&#x3D;&quot;home&quot; style&#x3D;&quot;height:1500px;width:100%;&quot;&gt;\n        &lt;div class&#x3D;&quot;box&quot; id&#x3D;&quot;box&quot; style&#x3D;&quot;height: 200px; width: 500px; background-color: red;margin-top: 50px;float: left;&quot;&gt;\n            \n        &lt;&#x2F;div&gt;\n   &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;script&gt;\n    const ele &#x3D; document.getElementById(&#39;box&#39;)\n\n    window.addEventListener(&#39;scroll&#39;,e&#x3D;&gt;&#123;\n        &#x2F;&#x2F; let a &#x3D; isEleVisible1(ele)\n        &#x2F;&#x2F; let b &#x3D; isEleVisible2(ele)\n        let c &#x3D; isEleVisible3(ele)\n        &#x2F;&#x2F; console.log(c);\n        &#x2F;&#x2F; console.log(a);\n        &#x2F;&#x2F; console.log(b);\n    &#125;)\n\n    &#x2F;&#x2F; 第一种 使用getBoundingClientRect()方法 \n    function isEleVisible1(ele)&#123;\n    var &#123;top, right, bottom, left&#125; &#x3D; ele.getBoundingClientRect()\n    var w &#x3D; window.innerWidth\n    var h &#x3D; window.innerHeight\n    if(bottom &lt; 0 || top &gt; h)&#123;\n        &#x2F;&#x2F; y 轴方向\n        return false\n    &#125;\n    if(right &lt; 0 || left &gt; w)&#123;\n        &#x2F;&#x2F; x 轴方向\n        return false\n    &#125;\n\n    return true\n&#125;\n    &#x2F;&#x2F;第二种使用原生方法\n    function isEleVisible2(ele)&#123;\n        &#x2F;&#x2F;元素距离顶部的距离\n        let top &#x3D; ele.offsetTop\n        &#x2F;&#x2F;滚动条距离顶部距离\n        let sorlltop &#x3D; document.documentElement.scrollTop || document.body.scrollTop;\n        &#x2F;&#x2F;元素的高度\n        let elementHeight &#x3D; ele.offsetHeight;\n\n        &#x2F;&#x2F;滚动条减去元素高度减去元素距离顶部高度小于0时 就是可视区域\n        if(sorlltop-elementHeight-top &lt; 0)&#123;\n            return true\n        &#125;else&#123;\n            return false\n        &#125;\n        \n    &#125;\n\n    &#x2F;&#x2F;第三种 使用IntersectionObserver\n    function isEleVisible3(ele)&#123;\n        const observer &#x3D; new IntersectionObserver(\n            ([entry]) &#x3D;&gt; &#123;\n                if(entry.isIntersecting)&#123;\n                    console.log(&#39;在&#39;);\n                &#125;else&#123;\n                    console.log(&#39;不在&#39;);\n                &#125;\n            &#125;,\n            &#123;\n                root:null,\n                rootMargin: &#39;0px&#39;,\n                threshold: 0,\n            &#125;\n        );\n        observer.observe(ele)\n        \n    &#125;\n&lt;&#x2F;script&gt;\n&lt;&#x2F;html&gt;\n\n","slug":"判断是否在可视范围","date":"2022-11-25T10:53:51.000Z","categories_index":"技术","tags_index":"","author_index":"假面骑士投"},{"id":"bd5a890e9dbc9ca0b4d22870a7589cb4","title":"js排序","content":"js排序&#x2F;&#x2F;冒泡排序\nfunction bubbleSort(arr) &#123;\n  var len &#x3D; arr.length;\n  for (var i &#x3D; 0; i &lt; len; i++) &#123;\n    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;\n      if (arr[j] &gt; arr[j + 1]) &#123;        &#x2F;&#x2F;相邻元素两两对比\n        var temp &#x3D; arr[j + 1];        &#x2F;&#x2F;元素交换\n        arr[j + 1] &#x3D; arr[j];\n        arr[j] &#x3D; temp;\n      &#125;\n    &#125;\n  &#125;\n  return arr;\n&#125;\nvar arr &#x3D; [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log(bubbleSort(arr));&#x2F;&#x2F;[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n&#x2F;&#x2F;选择排序\nfunction selectionSort(arr) &#123;\n  var len &#x3D; arr.length;\n  var minIndex, temp;\n  console.time(&#39;选择排序耗时&#39;);\n  for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;\n    minIndex &#x3D; i;\n    for (var j &#x3D; i + 1; j &lt; len; j++) &#123;\n      if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数\n        minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存\n      &#125;\n    &#125;\n    temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[minIndex];\n    arr[minIndex] &#x3D; temp;\n  &#125;\n  console.timeEnd(&#39;选择排序耗时&#39;);\n  return arr;\n&#125;\nvar arr &#x3D; [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log(selectionSort(arr));&#x2F;&#x2F;[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n&#x2F;&#x2F; 快速排序\nfunction quickSort(arr) &#123;\n  if (arr.length &lt;&#x3D; 1) &#123;\n    return arr;\n  &#125;\n  const pivotIndex &#x3D; Math.floor(arr.length &#x2F; 2);\n  const pivot &#x3D; arr.splice(pivotIndex, 1)[0];\n  const left &#x3D; [];\n  const right &#x3D; [];\n  for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n    if (arr[i] &lt; pivot) &#123;\n      left.push(arr[i]);\n    &#125; else &#123;\n      right.push(arr[i]);\n    &#125;\n  &#125;\n  return [...quickSort(left), pivot, ...quickSort(right)];\n&#125;\nvar arr &#x3D; [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log(quickSort(arr));&#x2F;&#x2F;[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n","slug":"排序","date":"2022-11-25T10:53:51.000Z","categories_index":"技术","tags_index":"","author_index":"假面骑士投"},{"id":"a21be972140e98b9ecfe6c6641e2d078","title":"react笔记！","content":"前端常用小方法1、浏览器监听是否全屏window.onresize &#x3D; function ()&#123;\n  var isFull &#x3D; document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;\n  if(isFull)&#123;\n    console.log(&#39;全屏&#39;)\n  &#125; else&#123;\n  \tconsole.log(&#39;没有全屏&#39;)\n  &#125;\n&#125;\n\n\n\n2、禁用某一个按钮（这个是禁用F11）window.onkeydown &#x3D; function (event) &#123;\n    if (event.keyCode &#x3D;&#x3D;&#x3D; 122) &#123;\n      event.preventDefault()\n      event.returnValue &#x3D; false\n    &#125;\n  &#125;\n\n\n\n3、实现点击全屏&#x2F;&#x2F; 全屏\n    function launchFullScreen(element) &#123;\n        if (element.requestFullscreen) &#123;\n            element.requestFullscreen();\n        &#125; else if (element.mozRequestFullScreen) &#123;\n            element.mozRequestFullScreen();\n        &#125; else if (element.webkitRequestFullscreen) &#123;\n            element.webkitRequestFullscreen();\n        &#125; else if (element.msRequestFullscreen) &#123;\n            element.msRequestFullscreen();\n        &#125;\n    &#125;\n\n&#x2F;&#x2F;退出全屏\nfunction exitFullscreen() &#123;\n    console.log(1111);\n    if (document.exitFullscreen) &#123;\n        window.document.exitFullscreen();\n    &#125; else if (document.mozExitFullScreen) &#123;\n        window.document.mozExitFullScreen();\n    &#125; else if (document.webkitExitFullscreen) &#123;\n        window.document.webkitExitFullscreen();\n    &#125;\n&#125;\n\n4、JavaScript强制刷新页面window.location.reload() *&#x2F;&#x2F; 强制页面刷新*\n\n5、Echarts和Datav实现响应式1、Echarts \nwindow.addEventListener(&#39;resize&#39;,function()&#123;\n\n \tmyChart1.resize()\n   mychart2.resize()\n\n &#125;)\n\n2、datav\n给需要响应式的图表添加一个key，在父容器发生变化的时候，更新key值即可。\n","slug":"react笔记","date":"2022-11-24T10:53:51.000Z","categories_index":"技术","tags_index":"","author_index":"假面骑士投"},{"id":"f70bf64eabbded8a2bd4b5fac72c7ba7","title":"从零开始搭建Hexo+Auroar个人博客！","content":"微前端笔记https://www.jianshu.com/p/4978d6e54937  参考链接\n\n\n\n\n\n\n\n\n\n\n工程越来越大，打包越来越慢\n团队人员多，产品功能复杂，代码冲突频繁、影响面大\n技术栈单一，无法灵活扩展\n\n定义：单个复杂应用分解成由一个主应用和多个子应用聚合而成的系统。通过主应用来加载子应用，而子应用由不同的功能按照不同的维度拆分而来。各个子应用可以独立开发、独立部署。\n\n\n\n\n\n\n\n\n\n基座模式， 自组织模式， 【选择使用基座模式】 一个主应用 接入多个微应用\n注册表模式，在主应用中注册子应用的方式.\n应用注册。即提供新的微前端应用，向应用注册表注册功能。\n应用发现。让主应用可以寻找到其它应用。\njs接入方式        HTML entry  接入微应用\n简单的微前端应用https://qiankun.umijs.org/zh/guide/getting-started\n\n\n\n\n\n\n\n\n\n主应用用的是Vue2框架， webpack 构建\n微应用： vue2框架，  react框架的接入\n\n主应用中 安装qiankun库，注册子微应用，可以react框，vue框架，或者其他的都可以。启动应用\n\ncnpm i qiankun -S &#x2F;&#x2F;安装命令\n\n主应用中\n\n\n\n\n\n\n\n\n\n建立一个文件夹乾坤，定义子应用注册信息的内容\n入口文件main.js中导入注册注册，使用乾坤的api完成应用注册，并启动应用。\n修改路由模式为历史路由模式，\n\n&#x2F;&#x2F;定义子应用的注册表数据内容\nexport const microApps &#x3D; [\n    &#123;\n        name: &#39;vue_app&#39;, &#x2F;&#x2F; app name registered\n        entry: &#39;&#x2F;&#x2F;localhost:8081&#39;,\n        container: &#39;#container&#39;,&#x2F;&#x2F;容器挂载\n        activeRule: &#39;&#x2F;vue_app&#39;,\n    &#125;,\n    &#123;\n        name: &#39;react_app&#39;, &#x2F;&#x2F; app name registered\n        entry: &#39;&#x2F;&#x2F;localhost:3000&#39;,\n        container: &#39;#container&#39;,\n        activeRule: &#39;&#x2F;react_app&#39;,\n    &#125;\n]\n\nmain.js中引入乾坤注册应用\n\nimport &#123; microApps &#125; from &#39;.&#x2F;qiankun&#x2F;microApps&#39;;\nimport &#123;registerMicroApps,start&#125; from &quot;qiankun&quot;;\n......&#x2F;&#x2F;&#x2F;\n\n&#x2F;&#x2F;注册和启动的过程\nregisterMicroApps(microApps);\nstart();\n\n\n\n\n启动所有应用通过安装一个插件 npm-run-all  插件，配置启动多个应用服务。\n&#123;\n  &quot;name&quot;: &quot;qiankun_package&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;微前端&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: &#123;\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,\n    &quot;start&quot;:&quot;npm-run-all start:*&quot;,\n    &quot;start:main&quot;:&quot;cd main &amp;&amp; start cmd &#x2F;k npm run serve&quot;,\n    &quot;start:vue&quot;:&quot;cd vue3_app &amp;&amp; start cmd &#x2F;k npm run serve&quot;,\n    &quot;start:react&quot;:&quot;cd react_app &amp;&amp; start cmd &#x2F;k npm start&quot;\n  &#125;,\n  &quot;keywords&quot;: [\n    &quot;qiankun&quot;,\n    &quot;microApps&quot;\n  ],\n  &quot;author&quot;: &quot;Liguanh&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;devDependencies&quot;: &#123;\n    &quot;npm-run-all&quot;: &quot;^4.1.5&quot;\n  &#125;\n&#125;\n\n\n\n\n微应用Vue微应用\n\n\n\n\n\n\n\n\n\n\n新增 public-path.js 文件，用于修改运行时的 publicPath。什么是运行时的 publicPath ？。\n\n注意：运行时的 publicPath 和构建时的 publicPath 是不同的，两者不能等价替代。\n&#x2F;&#x2F;路由的public路径的判断的内容\nif (window.__POWERED_BY_QIANKUN__) &#123;\n    __webpack_public_path__ &#x3D; window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n微应用建议使用 history 模式的路由，需要设置路由 base，值和它的 activeRule 是一样的。\n\n&#x2F;&#x2F;路由文件\n\nconst router &#x3D; createRouter(&#123;\n  history: createWebHistory(window.__POWERED_BY_QIANKUN__ ? &#39;&#x2F;vue_app&#39; : &#39;&#x2F;&#39;),\n  routes\n&#125;)\n\n\n\n\n\n\n\n\n\n\n\n\n\n在入口文件最顶部引入 public-path.js，修改并导出三个生命周期函数。\n\nimport &quot;.&#x2F;public-path&quot;;&#x2F;&#x2F;导入配置的信息\n...\n\n&#x2F;&#x2F;定义好对应的数据内容\nlet routes &#x3D; null;\nlet instance &#x3D; null;\n\n&#x2F;&#x2F;自定义渲染视图的方法\nfunction render(props &#x3D; &#123;&#125;) &#123;\n    const &#123; container &#125; &#x3D; props;\n    instance &#x3D; createApp(App);\n    instance.use(store).use(router).mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;)\n&#125;\n\n&#x2F;&#x2F; 独立运行时\nif (!window.__POWERED_BY_QIANKUN__) &#123;\n    render();\n&#125;\n\n&#x2F;&#x2F;乾坤的钩子函数的内容\nexport async function bootstrap() &#123;\n    console.log(&#39;[vue] vue app bootstraped&#39;);\n  &#125;\n  export async function mount(props) &#123;\n    console.log(&#39;[vue] props from main framework&#39;, props);\n    render(props);\n  &#125;\n  export async function unmount() &#123;\n    &#x2F;&#x2F;销毁声明周期的时候做的操作\n    instance.unmount();\n    instance._container.innerHTML &#x3D; &#39;&#39;;\n    instance &#x3D; null;\n    &#x2F;&#x2F; routes &#x3D; null;\n  &#125;\n\n\n\n\n\n\n\n\n\n\n\n修改 webpack 打包，允许开发环境跨域和 umd 打包。\n\n&#x2F;&#x2F;vue.config.js\nconst &#123; name &#125; &#x3D; require(&#39;.&#x2F;package&#39;);\nmodule.exports &#x3D; defineConfig(&#123;\n  transpileDependencies: true,\n  devServer:&#123;\n    port:8081,\n    headers: &#123;\n      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#125;,\n  &#125;,\n  configureWebpack: &#123;\n    output: &#123;\n      library: &#96;$&#123;name&#125;-[name]&#96;,\n      libraryTarget: &#39;umd&#39;, &#x2F;&#x2F; 把微应用打包成 umd 库格式\n      &#x2F;&#x2F; jsonpFunction: &#96;webpackJsonp_$&#123;name&#125;&#96;, &#x2F;&#x2F; webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal\n      chunkLoadingGlobal: &#96;webpackJsonp_$&#123;name&#125;&#96;, &#x2F;&#x2F; webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal\n    &#125;,\n  &#125;,\n&#125;)\n\n\n\n\nReact 微应用\n\n\n\n\n\n\n\n\n\n\n新增 public-path.js 文件，用于修改运行时的 publicPath。什么是运行时的 publicPath ？。\n\n注意：运行时的 publicPath 和构建时的 publicPath 是不同的，两者不能等价替代。\n&#x2F;&#x2F;路由的public路径的判断的内容\nif (window.__POWERED_BY_QIANKUN__) &#123;\n    &#x2F;&#x2F; eslint-disable-next-line\n    __webpack_public_path__ &#x3D; window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n微应用建议使用 history 模式的路由，需要设置路由 base，值和它的 activeRule 是一样的。\n\n\n\n\n\n\n\n\n\n\n\n在入口文件最顶部引入 public-path.js，修改并导出三个生命周期函数。\n\n&#x2F;&#x2F;index.js\nimport &#39;.&#x2F;public-path&#39;;\n....\nlet root;\nfunction render(props &#x3D; &#123;&#125;) &#123;\n  const &#123; container &#125; &#x3D; props;\n  root &#x3D; ReactDOM.createRoot(container ? container.querySelector(&#39;#root&#39;) : document.querySelector(&#39;#root&#39;));\n  root.render(\n    &lt;React.StrictMode&gt;\n      &lt;App &#x2F;&gt;\n    &lt;&#x2F;React.StrictMode&gt;\n  );\n&#125;\n\nif (!window.__POWERED_BY_QIANKUN__) &#123;\n  render(&#123;&#125;);\n&#125;\n\nexport async function bootstrap() &#123;\n  console.log(&#39;[react16] react app bootstraped&#39;);\n&#125;\n\nexport async function mount(props) &#123;\n  console.log(&#39;[react16] props from main framework&#39;, props);\n  render(props);\n&#125;\n\nexport async function unmount(props) &#123;\n  const &#123; container &#125; &#x3D; props;\n  &#x2F;&#x2F; ReactDOM.unmountComponentAtNode(container ? container.querySelector(&#39;#root&#39;) : document.querySelector(&#39;#root&#39;));\n  root.unmount();\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n修改 webpack 打包，允许开发环境跨域和 umd 打包。\n安装插件 @rescripts/cli，当然也可以选择其他的插件，例如 react-app-rewired。\ncnpm i @rescripts&#x2F;cli -D\n\n\n根目录新增 .rescriptsrc.js：\nconst &#123; name &#125; &#x3D; require(&#39;.&#x2F;package&#39;);\n\nmodule.exports &#x3D; &#123;\n  webpack: (config) &#x3D;&gt; &#123;\n    config.output.library &#x3D; &#96;$&#123;name&#125;-[name]&#96;;\n    config.output.libraryTarget &#x3D; &#39;umd&#39;;\n    &#x2F;&#x2F; webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal\n    &#x2F;&#x2F; config.output.jsonpFunction &#x3D; &#96;webpackJsonp_$&#123;name&#125;&#96;; \n    config.output.chunkLoadingGlobal &#x3D; &#96;webpackJsonp_$&#123;name&#125;&#96;; \n    config.output.globalObject &#x3D; &#39;window&#39;;\n\n    return config;\n  &#125;,\n  devServer: (_) &#x3D;&gt; &#123;\n    const config &#x3D; _;\n\n    config.headers &#x3D; &#123;\n      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,\n    &#125;;\n    config.historyApiFallback &#x3D; true;\n    config.hot &#x3D; false;\n    &#x2F;&#x2F; config.watchContentBase &#x3D; false;\n    config.liveReload &#x3D; false;\n\n    return config;\n  &#125;,\n&#125;;\n\nhttps://qiankun.umijs.org/zh/guide/getting-started   微应用配置\nhttps://gitee.com/liguanh/qiankun_demo.git  仓库地址展示\n参考资料相关接入Vue2  和react等  https://qiankun.umijs.org/zh/guide/tutorial#react-%E5%BE%AE%E5%BA%94%E7%94%A8\n接入Vue3的项目内容操作方法如下实现：https://blog.csdn.net/weixin_44171297/article/details/127479436\nhttps://blog.csdn.net/AK852369/article/details/127430028  例子\n数据传递的方法：  http://events.jianshu.io/p/0bc357c3c014\nhttps://gitee.com/liguanh/qiankun_demo.git\n微前端qiankun接入Vite子应用含Vue3和React18： https://blog.csdn.net/AK852369/article/details/127430028\n参考的乾坤项目gitee的链接地址信息： \nhttps://gitee.com/nwebli/qiankun-vue2.0.git\nhttps://gitee.com/zixuanmoon/qiankun-demo.git\n常见问题子应用容器挂载的问题？应用组件通信的方法有哪些？https://betheme.net/dashuju/43888.html?action=onClick\n主应用和子应用样式混乱的问题css样式隔离https://www.jianshu.com/p/67585c603dd2\n","slug":"乾坤-微前端的笔记(2)","date":"2022-11-24T10:53:51.000Z","categories_index":"技术","tags_index":"技术","author_index":"假面骑士投"}]